# Azure Pipeline for KhulaFxAdminNew (Frontend Angular)
# GitHub Repository: https://github.com/fjadula/KhulaFxAdminNew
# Branch: master

trigger:
  branches:
    include:
      - master
      - main

resources:
  repositories:
    - repository: self
      type: github
      name: fjadula/KhulaFxAdminNew
      endpoint: github
      fetchDepth: 1

pool:
  name: 'Default'

variables:
  - group: 'Deployment-Secrets'

stages:
  - stage: NotifyStart
    displayName: 'Notify Build Started'
    jobs:
      - job: Telegram
        displayName: 'Send Telegram Notification'
        steps:
          - task: PowerShell@2
            displayName: 'Send Start Notification'
            inputs:
              targetType: 'inline'
              script: |
                $message = "üöÄ *KhulaFxAdmin Frontend Build Started*`n`n"
                $message += "üì¶ *Project:* KhulaFxAdminNew (Angular)`n"
                $message += "üî¢ *Build:* $(Build.BuildNumber)`n"
                $message += "üë§ *By:* $(Build.RequestedFor)`n"
                $message += "üåø *Branch:* $(Build.SourceBranchName)`n"
                $message += "üí¨ *Commit:* $(Build.SourceVersionMessage)`n"
                $message += "üîó [View](https://dev.azure.com/KhulaFx/KhulaFxTrade/_build/results?buildId=$(Build.BuildId))"
                
                $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
                
                try {
                  Invoke-RestMethod -Uri "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage" -Method Post -ContentType "application/json" -Body $body
                } catch { Write-Warning "Telegram failed: $_" }

  - stage: Build
    displayName: 'Build Angular Application'
    dependsOn: NotifyStart
    jobs:
      - job: BuildAngular
        displayName: 'Build Angular'
        steps:
          - checkout: self
            clean: true
            fetchDepth: 1

          - task: PowerShell@2
            displayName: 'Verify Repository'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Build Source Directory: $(Build.SourcesDirectory)" -ForegroundColor Cyan
                Write-Host "Build Repository: $(Build.Repository.Name)" -ForegroundColor Cyan
                
                $packagePath = "$(Build.SourcesDirectory)/package.json"
                Write-Host "Looking for: $packagePath" -ForegroundColor Yellow
                Write-Host ""
                
                if (Test-Path $packagePath) {
                  Write-Host "‚úÖ package.json FOUND" -ForegroundColor Green
                  Write-Host "Contents:" -ForegroundColor Gray
                  Get-Content $packagePath | Select-Object -First 5
                } else {
                  Write-Host "‚ùå package.json NOT FOUND" -ForegroundColor Red
                  Write-Host "Directory contents:" -ForegroundColor Yellow
                  Get-ChildItem -Path "$(Build.SourcesDirectory)" -Force -Depth 2
                  exit 1
                }

          - task: NodeTool@0
            displayName: 'Install Node.js 18'
            inputs:
              versionSpec: '18.x'

          - task: PowerShell@2
            displayName: 'Set Node Memory Limit'
            inputs:
              targetType: 'inline'
              script: |
                $env:NODE_OPTIONS="--max-old-space-size=4096"
                Write-Host "‚úÖ Set Node memory limit to 4GB" -ForegroundColor Green

          - task: Npm@1
            displayName: 'npm install'
            inputs:
              command: 'install'
              workingDir: '$(Build.SourcesDirectory)'

          - task: PowerShell@2
            displayName: 'Generate environment.prod.ts'
            inputs:
              targetType: 'inline'
              script: |
                $apiUrl = "$(apiUrl)"
                Write-Host "Generating environment with API: $apiUrl" -ForegroundColor Cyan
                
                $envContent = @"
export const environment = {
  production: true,
  apiUrl: '$apiUrl'
};
"@
                
                $envPath = "$(Build.SourcesDirectory)/src/environments/environment.prod.ts"
                $envDir = Split-Path -Path $envPath
                
                if (-not (Test-Path $envDir)) {
                  New-Item -ItemType Directory -Path $envDir -Force | Out-Null
                }
                
                $envContent | Out-File -FilePath $envPath -Encoding utf8 -Force
                Write-Host "‚úÖ Generated environment.prod.ts" -ForegroundColor Green

          - task: Npm@1
            displayName: 'npm build production'
            inputs:
              command: 'custom'
              workingDir: '$(Build.SourcesDirectory)'
              customCommand: 'run build -- --configuration production --base-href=/secure-admin/'

          - task: PowerShell@2
            displayName: 'Find and prepare dist folder'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Searching for dist folder..." -ForegroundColor Cyan
                
                $distFolder = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "dist" -Directory -Force | Select-Object -First 1
                
                if (-not $distFolder) {
                  Write-Error "dist folder not found"
                  Write-Host "Directory contents:" -ForegroundColor Yellow
                  Get-ChildItem -Path "$(Build.SourcesDirectory)" -Force
                  exit 1
                }
                
                Write-Host "‚úÖ Found dist: $($distFolder.FullName)" -ForegroundColor Green
                
                # Look for browser subfolder (Angular 17+)
                $browserFolder = Get-ChildItem -Path $distFolder.FullName -Filter "browser" -Directory -Force | Select-Object -First 1
                
                if ($browserFolder) {
                  $deployPath = $browserFolder.FullName
                  Write-Host "‚úÖ Using browser folder: $deployPath" -ForegroundColor Green
                } else {
                  $deployPath = $distFolder.FullName
                  Write-Host "‚úÖ Using dist folder: $deployPath" -ForegroundColor Green
                }
                
                Write-Host "##vso[task.setvariable variable=DeployPath]$deployPath"

          - task: PowerShell@2
            displayName: 'Create web.config'
            inputs:
              targetType: 'inline'
              script: |
                $deployPath = "$(DeployPath)"
                
                $webConfig = @"
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
    <rewrite>
      <rules>
        <rule name="Angular Routes" stopProcessing="true">
          <match url=".*" />
          <conditions logicalGrouping="MatchAll">
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
          </conditions>
          <action type="Rewrite" url="index.html" />
        </rule>
      </rules>
    </rewrite>
  </system.webServer>
</configuration>
"@
                
                $webConfig | Out-File -FilePath "$deployPath/web.config" -Encoding utf8 -Force
                Write-Host "‚úÖ web.config created" -ForegroundColor Green

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Artifacts'
            inputs:
              pathToPublish: '$(DeployPath)'
              artifactName: 'frontend'

  - stage: Deploy
    displayName: 'Deploy to VPS'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - job: DeployFrontend
        displayName: 'Deploy to IIS'
        steps:
          - download: current
            artifact: frontend

          - task: PowerShell@2
            displayName: 'Deploy to IIS'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "========================================" -ForegroundColor Cyan
                Write-Host "Deploying Frontend" -ForegroundColor Cyan
                Write-Host "========================================" -ForegroundColor Cyan
                
                $sourcePath = "$(Pipeline.Workspace)/frontend"
                $vpsIP = "$(vpsServer)"
                $destinationPath = "\\$vpsIP\c$\TRADERVPS\Sites\khulafx.com\secure-admin"
                
                Write-Host "Source: $sourcePath" -ForegroundColor White
                Write-Host "Destination: $destinationPath" -ForegroundColor White
                
                try {
                  # Verify source
                  if (-not (Test-Path $sourcePath)) {
                    Write-Error "Source not found: $sourcePath"
                    exit 1
                  }
                  
                  Write-Host "`nVerifying source files..." -ForegroundColor Yellow
                  $sourceFiles = Get-ChildItem -Path $sourcePath -Force
                  Write-Host "‚úÖ Found $($sourceFiles.Count) items to deploy" -ForegroundColor Green
                  
                  # Create destination if needed
                  if (-not (Test-Path $destinationPath)) {
                    New-Item -ItemType Directory -Path $destinationPath -Force | Out-Null
                    Write-Host "‚úÖ Created destination directory" -ForegroundColor Green
                  }
                  
                  # Clean destination
                  Write-Host "`nCleaning destination..." -ForegroundColor Yellow
                  Get-ChildItem -Path $destinationPath -Force -ErrorAction SilentlyContinue | Where-Object { $_.Name -ne "web.config" } | ForEach-Object {
                    try {
                      if ($_.PSIsContainer) {
                        Remove-Item -Path $_.FullName -Recurse -Force -ErrorAction Stop
                      } else {
                        Remove-Item -Path $_.FullName -Force -ErrorAction Stop
                      }
                    } catch {}
                  }
                  Write-Host "‚úÖ Cleaned destination" -ForegroundColor Green
                  
                  Start-Sleep -Seconds 1
                  
                  # Copy files
                  Write-Host "`nCopying files..." -ForegroundColor Yellow
                  Get-ChildItem -Path $sourcePath -Force | ForEach-Object {
                    try {
                      if ($_.PSIsContainer) {
                        Copy-Item -Path $_.FullName -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                      } else {
                        Copy-Item -Path $_.FullName -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                      }
                      Write-Host "‚úÖ $_" -ForegroundColor Green
                    } catch {
                      Write-Host "‚ö†Ô∏è $_" -ForegroundColor Yellow
                    }
                  }
                  
                  # Verify
                  $indexExists = Test-Path "$destinationPath\index.html"
                  
                  Write-Host ""
                  Write-Host "========================================" -ForegroundColor Green
                  Write-Host "‚úÖ Deployment Complete!" -ForegroundColor Green
                  Write-Host "========================================" -ForegroundColor Green
                  Write-Host "index.html: $(if($indexExists){'‚úÖ Found'}else{'‚ùå Missing'})" -ForegroundColor $(if($indexExists){'Green'}else{'Red'})
                  
                  if (-not $indexExists) {
                    Write-Error "Deployment failed: index.html not found"
                    exit 1
                  }
                }
                catch {
                  Write-Host "========================================" -ForegroundColor Red
                  Write-Host "‚ùå Deployment Failed!" -ForegroundColor Red
                  Write-Host "========================================" -ForegroundColor Red
                  Write-Error $_.Exception.Message
                  exit 1
                }

          - task: PowerShell@2
            displayName: 'Verify Website'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Waiting for IIS..." -ForegroundColor Yellow
                Start-Sleep -Seconds 5
                
                $urls = @(
                  "https://khulafx.com/secure-admin",
                  "http://108.181.161.170/secure-admin"
                )
                
                foreach ($url in $urls) {
                  try {
                    Write-Host "Testing: $url" -ForegroundColor Gray
                    $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10 -ErrorAction Stop
                    Write-Host "‚úÖ Status: $($response.StatusCode)" -ForegroundColor Green
                    Write-Host "‚úÖ Website Live!" -ForegroundColor Green
                    break
                  }
                  catch {
                    Write-Host "‚ö†Ô∏è Not yet available" -ForegroundColor Yellow
                  }
                }

  - stage: NotifyComplete
    displayName: 'Notify Completion'
    dependsOn: Deploy
    condition: always()
    jobs:
      - job: SendResult
        displayName: 'Send Notification'
        steps:
          - task: PowerShell@2
            displayName: 'Send Telegram'
            inputs:
              targetType: 'inline'
              script: |
                $success = "$(Agent.JobStatus)" -eq "Succeeded"
                $icon = if ($success) { "‚úÖ" } else { "‚ùå" }
                $status = if ($success) { "SUCCESS" } else { "FAILED" }
                
                $message = "$icon *Frontend Deploy $status*`n`n"
                $message += "üì¶ KhulaFxAdminNew`n"
                $message += "üî¢ Build: $(Build.BuildNumber)`n"
                $message += "üåø Branch: $(Build.SourceBranchName)`n"
                
                if ($success) {
                  $message += "üåê https://khulafx.com/secure-admin`n"
                }
                
                $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
                
                try {
                  Invoke-RestMethod -Uri "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage" -Method Post -ContentType "application/json" -Body $body
                } catch { Write-Warning "Telegram notification skipped" }
