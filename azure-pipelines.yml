# Azure Pipeline for KhulaFxAdminNew (Frontend Angular)
# Auto-detects environment and builds with correct API endpoint from pipeline variables

trigger:
  branches:
    include:
      - main
      - master

pool:
  name: 'Default'

variables:
  - group: 'Deployment-Secrets'

stages:
  - stage: NotifyStart
    displayName: 'Notify Build Started'
    jobs:
      - job: Telegram
        displayName: 'Send Telegram Notification'
        steps:
          - task: PowerShell@2
            displayName: 'Send Start Notification'
            inputs:
              targetType: 'inline'
              script: |
                $message = "üöÄ *KhulaFxAdmin Frontend Build Started*`n`n"
                $message += "üì¶ *Project:* KhulaFxAdminNew (Angular)`n"
                $message += "üî¢ *Build:* $(Build.BuildNumber)`n"
                $message += "üë§ *By:* $(Build.RequestedFor)`n"
                $message += "üåø *Branch:* $(Build.SourceBranchName)`n"
                $message += "üí¨ *Commit:* $(Build.SourceVersionMessage)`n"
                $message += "üîó [View](https://dev.azure.com/KhulaFx/KhulaFxTrade/_build/results?buildId=$(Build.BuildId))"
                
                $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
                
                try {
                  Invoke-RestMethod -Uri "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage" -Method Post -ContentType "application/json" -Body $body
                } catch { Write-Warning "Telegram failed: $_" }

  - stage: Build
    displayName: 'Build Angular Application'
    dependsOn: NotifyStart
    jobs:
      - job: BuildAngular
        displayName: 'Build Angular'
        steps:
          - checkout: self
            fetchDepth: 1

          - task: PowerShell@2
            displayName: 'Verify Repository Structure'
            inputs:
              targetType: 'inline'
              script: |
                $packagePath = "$(Build.SourcesDirectory)/package.json"
                Write-Host "Checking: $packagePath" -ForegroundColor Cyan
                
                if (Test-Path $packagePath) {
                  Write-Host "‚úÖ package.json found" -ForegroundColor Green
                  Get-Content $packagePath | Select-Object -First 10
                } else {
                  Write-Host "‚ùå package.json NOT found" -ForegroundColor Red
                  Write-Host "Contents of $(Build.SourcesDirectory):" -ForegroundColor Yellow
                  Get-ChildItem -Path "$(Build.SourcesDirectory)" -Force
                  exit 1
                }

          - task: NodeTool@0
            displayName: 'Install Node.js'
            inputs:
              versionSpec: '18.x'

          - task: PowerShell@2
            displayName: 'Set Node Memory Limit'
            inputs:
              targetType: 'inline'
              script: |
                $env:NODE_OPTIONS="--max-old-space-size=4096"
                Write-Host "‚úÖ Set Node memory limit to 4GB" -ForegroundColor Green

          - task: PowerShell@2
            displayName: 'Agent debug - list sources'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Agent info" -ForegroundColor Cyan
                Write-Host "  Agent.WorkFolder: $(Agent.WorkFolder)"
                Write-Host "  Pipeline.Workspace: $(Pipeline.Workspace)"
                Write-Host "  Build.SourcesDirectory: $(Build.SourcesDirectory)"
                Write-Host "  System.DefaultWorkingDirectory: $(System.DefaultWorkingDirectory)"
                Write-Host ""
                Write-Host "Listing top-level contents of Build.SourcesDirectory:" -ForegroundColor Yellow
                Get-ChildItem -Path "$(Build.SourcesDirectory)" -Force | Sort-Object -Property PSIsContainer -Descending
                Write-Host ""
                Write-Host "Looking for package.json recursively (max depth 4):" -ForegroundColor Yellow
                Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "package.json" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName

          - task: Npm@1
            displayName: 'npm install'
            inputs:
              command: 'install'
              workingDir: '$(Build.SourcesDirectory)'

          - task: PowerShell@2
            displayName: 'Generate environment.prod.ts with API endpoint'
            inputs:
              targetType: 'inline'
              script: |
                $apiUrl = "$(apiUrl)"
                
                Write-Host "Generating environment file with API: $apiUrl" -ForegroundColor Cyan
                
                $envContent = @"
export const environment = {
  production: true,
  apiUrl: '$apiUrl'
};
"@
                
                $envPath = "$(Build.SourcesDirectory)/src/environments/environment.prod.ts"
                
                # Create directory if it doesn't exist
                $envDir = Split-Path -Path $envPath
                if (-not (Test-Path $envDir)) {
                  New-Item -ItemType Directory -Path $envDir -Force | Out-Null
                  Write-Host "Created: $envDir" -ForegroundColor Yellow
                }
                
                $envContent | Out-File -FilePath $envPath -Encoding utf8 -Force
                Write-Host "‚úÖ Generated: $envPath" -ForegroundColor Green
                Write-Host "Content:" -ForegroundColor Gray
                Get-Content $envPath

          - task: Npm@1
            displayName: 'npm build (production)'
            inputs:
              command: 'custom'
              workingDir: '$(Build.SourcesDirectory)'
              customCommand: 'run build -- --configuration production --base-href=/secure-admin/'

          - task: PowerShell@2
            displayName: 'Find dist folder'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Searching for dist folder..." -ForegroundColor Cyan
                
                $distFolder = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "dist" -Directory -Force | Select-Object -First 1
                
                if (-not $distFolder) {
                  Write-Error "dist folder not found"
                  exit 1
                }
                
                Write-Host "‚úÖ Found dist: $($distFolder.FullName)" -ForegroundColor Green
                
                # Look for browser subfolder
                $browserFolder = Get-ChildItem -Path $distFolder.FullName -Filter "browser" -Directory -Force | Select-Object -First 1
                
                if ($browserFolder) {
                  $deployPath = $browserFolder.FullName
                  Write-Host "‚úÖ Found browser folder: $deployPath" -ForegroundColor Green
                } else {
                  $deployPath = $distFolder.FullName
                  Write-Host "‚úÖ Using dist folder: $deployPath" -ForegroundColor Green
                }
                
                Write-Host "##vso[task.setvariable variable=DeployPath]$deployPath"

          - task: PowerShell@2
            displayName: 'Create web.config'
            inputs:
              targetType: 'inline'
              script: |
                $deployPath = "$(DeployPath)"
                
                $webConfig = @"
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <system.webServer>
    <rewrite>
      <rules>
        <rule name="Angular Routes" stopProcessing="true">
          <match url=".*" />
          <conditions logicalGrouping="MatchAll">
            <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="true" />
            <add input="{REQUEST_FILENAME}" matchType="IsDirectory" negate="true" />
          </conditions>
          <action type="Rewrite" url="index.html" />
        </rule>
      </rules>
    </rewrite>
  </system.webServer>
</configuration>
"@
                
                $webConfig | Out-File -FilePath "$deployPath/web.config" -Encoding utf8 -Force
                Write-Host "‚úÖ web.config created" -ForegroundColor Green

          - task: PublishBuildArtifacts@1
            displayName: 'Publish Artifacts'
            inputs:
              pathToPublish: '$(DeployPath)'
              artifactName: 'frontend'

  - stage: Deploy
    displayName: 'Deploy to VPS'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - job: DeployFrontend
        displayName: 'Deploy to IIS'
        steps:
          - download: current
            artifact: frontend

          - task: PowerShell@2
            displayName: 'Deploy via Network Share'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "========================================" -ForegroundColor Cyan
                Write-Host "Deploying Angular Frontend" -ForegroundColor Cyan
                Write-Host "========================================" -ForegroundColor Cyan
                
                $sourcePath = "$(Pipeline.Workspace)/frontend"
                $vpsIP = "$(vpsServer)"
                $destinationPath = "\\$vpsIP\c$\TRADERVPS\Sites\khulafx.com\secure-admin"
                
                Write-Host "Source: $sourcePath" -ForegroundColor White
                Write-Host "Destination: $destinationPath" -ForegroundColor White
                Write-Host ""
                
                try {
                  # Verify source
                  if (-not (Test-Path $sourcePath)) {
                    Write-Error "Source folder not found: $sourcePath"
                    exit 1
                  }
                  
                  $sourceFiles = Get-ChildItem -Path $sourcePath -Force
                  Write-Host "Source files: $($sourceFiles.Count)" -ForegroundColor Cyan
                  
                  # Ensure directory exists
                  if (-not (Test-Path $destinationPath)) {
                    New-Item -ItemType Directory -Path $destinationPath -Force | Out-Null
                    Write-Host "‚úÖ Created directory" -ForegroundColor Green
                  }
                  
                  # Clean destination
                  Write-Host "`nCleaning destination folder..." -ForegroundColor Yellow
                  $itemsToDelete = Get-ChildItem -Path $destinationPath -Force -ErrorAction SilentlyContinue
                  
                  $deletedCount = 0
                  foreach ($item in $itemsToDelete) {
                    if ($item.Name -eq "web.config") {
                      Write-Host "‚è≠Ô∏è  Skipping locked: web.config" -ForegroundColor Yellow
                      continue
                    }
                    
                    try {
                      if ($item.PSIsContainer) {
                        Remove-Item -Path $item.FullName -Recurse -Force -ErrorAction Stop
                      } else {
                        Remove-Item -Path $item.FullName -Force -ErrorAction Stop
                      }
                      $deletedCount++
                    } catch {
                      Write-Host "‚ö†Ô∏è  Skipping: $($item.Name)" -ForegroundColor Yellow
                    }
                  }
                  Write-Host "‚úÖ Cleaned $deletedCount items" -ForegroundColor Green
                  
                  Start-Sleep -Seconds 1
                  
                  # Copy files
                  Write-Host "`nCopying files..." -ForegroundColor Yellow
                  Get-ChildItem -Path $sourcePath -Force | ForEach-Object {
                    try {
                      if ($_.PSIsContainer) {
                        Copy-Item -Path $_.FullName -Destination $destinationPath -Recurse -Force -ErrorAction SilentlyContinue
                      } else {
                        Copy-Item -Path $_.FullName -Destination $destinationPath -Force -ErrorAction SilentlyContinue
                      }
                      Write-Host "‚úÖ $_" -ForegroundColor Green
                    } catch {
                      Write-Host "‚ö†Ô∏è  $_" -ForegroundColor Yellow
                    }
                  }
                  
                  Write-Host ""
                  Write-Host "========================================" -ForegroundColor Green
                  Write-Host "‚úÖ Deployment Complete!" -ForegroundColor Green
                  Write-Host "========================================" -ForegroundColor Green
                  
                  # Verify
                  $indexExists = Test-Path "$destinationPath\index.html"
                  $webConfigExists = Test-Path "$destinationPath\web.config"
                  
                  Write-Host "Key files:" -ForegroundColor Yellow
                  Write-Host "  ‚úÖ index.html: $(if($indexExists){'Found'}else{'MISSING'})" -ForegroundColor $(if($indexExists){'Green'}else{'Red'})
                  Write-Host "  ‚úÖ web.config: $(if($webConfigExists){'Found'}else{'MISSING'})" -ForegroundColor $(if($webConfigExists){'Green'}else{'Red'})
                  
                  if (-not $indexExists) {
                    Write-Error "Critical: index.html is missing!"
                    exit 1
                  }
                }
                catch {
                  Write-Host "========================================" -ForegroundColor Red
                  Write-Host "‚ùå Deployment Failed!" -ForegroundColor Red
                  Write-Host "========================================" -ForegroundColor Red
                  Write-Error $_.Exception.Message
                  exit 1
                }

          - task: PowerShell@2
            displayName: 'Recycle App Pool'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Recycling IIS app pool..." -ForegroundColor Yellow
                
                $vpsIP = "$(vpsServer)"
                $webConfigPath = "\\$vpsIP\c$\TRADERVPS\Sites\khulafx.com\secure-admin\web.config"
                
                try {
                  $content = Get-Content -Path $webConfigPath -Raw
                  $content | Out-File -FilePath $webConfigPath -Force
                  Write-Host "‚úÖ App pool recycle triggered" -ForegroundColor Green
                  Start-Sleep -Seconds 3
                }
                catch {
                  Write-Host "‚ö†Ô∏è  Could not trigger recycle: $($_.Exception.Message)" -ForegroundColor Yellow
                }

          - task: PowerShell@2
            displayName: 'Verify Website'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Waiting for IIS to initialize..." -ForegroundColor Yellow
                Start-Sleep -Seconds 8
                
                Write-Host "Testing website..." -ForegroundColor Yellow
                Write-Host ""
                
                $urls = @(
                  "https://khulafx.com/secure-admin",
                  "http://108.181.161.170/secure-admin"
                )
                
                $success = $false
                foreach ($url in $urls) {
                  try {
                    Write-Host "Testing: $url" -ForegroundColor Gray
                    $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 20 -ErrorAction Stop
                    Write-Host "  ‚úÖ Status: $($response.StatusCode)" -ForegroundColor Green
                    $success = $true
                    break
                  }
                  catch {
                    Write-Host "  ‚ö†Ô∏è  $($_.Exception.Message)" -ForegroundColor Yellow
                  }
                }
                
                Write-Host ""
                if ($success) {
                  Write-Host "========================================" -ForegroundColor Green
                  Write-Host "‚úÖ Website is Live and Accessible!" -ForegroundColor Green
                  Write-Host "========================================" -ForegroundColor Green
                  Write-Host "URL: https://khulafx.com/secure-admin" -ForegroundColor Cyan
                } else {
                  Write-Warning "Website not accessible yet"
                }

  - stage: NotifyComplete
    displayName: 'Notify Completion'
    dependsOn: Deploy
    condition: always()
    jobs:
      - job: SendResult
        displayName: 'Send Telegram Result'
        steps:
          - task: PowerShell@2
            displayName: 'Send Notification'
            inputs:
              targetType: 'inline'
              script: |
                $success = "$(Agent.JobStatus)" -eq "Succeeded"
                $icon = if ($success) { "‚úÖ" } else { "‚ùå" }
                $status = if ($success) { "SUCCESS" } else { "FAILED" }
                
                $message = "$icon *KhulaFxAdmin Frontend Deploy $status!*`n`n"
                $message += "üì¶ *Project:* KhulaFxAdminNew (Angular)`n"
                $message += "üî¢ *Build:* $(Build.BuildNumber)`n"
                $message += "üë§ *By:* $(Build.RequestedFor)`n"
                $message += "üåø *Branch:* $(Build.SourceBranchName)`n"
                
                if ($success) {
                  $message += "üåê *URL:* https://khulafx.com/secure-admin`n"
                  $message += "üîå *API:* $(apiUrl)`n"
                }
                
                $duration = [math]::Round((New-TimeSpan -Start '$(System.PipelineStartTime)' -End (Get-Date)).TotalMinutes, 2)
                $message += "‚è±Ô∏è  *Duration:* $duration minutes`n"
                $message += "üîó [View Logs](https://dev.azure.com/KhulaFx/KhulaFxTrade/_build/results?buildId=$(Build.BuildId))"
                
                $body = @{ chat_id = "$(TELEGRAM_CHAT_ID)"; text = $message; parse_mode = "Markdown" } | ConvertTo-Json
                
                try {
                  Invoke-RestMethod -Uri "https://api.telegram.org/bot$(TELEGRAM_BOT_TOKEN)/sendMessage" -Method Post -ContentType "application/json" -Body $body
                } catch { Write-Warning "Telegram failed: $_" }
